from random import randint


class Dot:  # Класс точек, атрибуты - координаты x и y
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):  # Переопределяем поведение оператора равенства ==
        return self.x == other.x and self.y == other.y

    def __repr__(self):  # Переопределяем поведение функции print()
        return f"({self.x}, {self.y})"


class BoardException(Exception):  # Общий класс ошибок
    pass


class BoardOutException(BoardException):  # Потомок BoardException. Будет вызываться при стрельбе за пределы поля
    def __str__(self):
        return "Вы пытаетесь выстрелить за доску!"


class BoardUsedException(BoardException):  # Потомок BoardException. Будет вызываться при стрельбе в проверенную точку
    def __str__(self):
        return "Вы уже стреляли в эту клетку!"


class BoardWrongShipException(BoardException):  # Потомок BoardException. Будет вызываться при плохом размещении корабля
    pass


class Ship:  # Класс кораблей, атрибуты: точка с координатами носа, длина, ориентация, количество жизней
    def __init__(self, bow, length, orientation):
        self.bow = bow
        self.length = length
        self.orientation = orientation  # 0 - горизонтальная ориентация, 1 - вертикальная ориентация
        self.lives = length  # Количество жизней корабля равно его длине

    @property
    def dots(self):  # На основе значений атрибутов корабля получаем список точек корабля
        ship_coordinates = []
        for i in range(self.length):  # При i=0 получаем координата носа, при i=length-1 - координаты хвоста
            current_x = self.bow.x
            current_y = self.bow.y
            if self.orientation == 0:  # Если ориентация равна 0, то расположение корабля горизонтальное
                current_x += i
            elif self.orientation == 1:  # Если ориентация равна 1, то расположение корабля вертикальное
                current_y += i
            ship_coordinates.append(Dot(current_x, current_y))  # Добавляем получившуюся точку в список точек корабля
        return ship_coordinates


class Board:  # Класс формирует игровое поле
    def __init__(self, size=6, hid=False):
        self.size = size  # Это размер поля, по условию задания он равен 6
        self.field = [[" "] * size for _ in range(size)]  # Игровое поле в виде двумерного массива
        self.count = 7  # Это количество живых кораблей. При 0 будет засчитано поражение.
        self.busy = []  # Список занятых клеток. Сперва используется для расстановки кораблей, потом для выстрелов
        self.ships = []  # Список кораблей
        self.hid = hid  # Скрывает расположение кораблей. Для пользователя - False, для ИИ - True

    def add_ship(self, ship):
        for i in ship.dots:                    # Проверка, что координаты точек корабля допустимы:
            if self.out(i) or i in self.busy:  # точка в пределах игрового поля и клетка ещё не занята
                raise BoardWrongShipException()
        for i in ship.dots:  # Отмечаем точки корабля символом "■" и добавляем их в список занятых точек
            if self.hid:  # Т.к. нам нужно скрыть корабли противника, они помечены "█" для удобства при выводе поля
                self.field[i.x][i.y] = "█"
            else:
                self.field[i.x][i.y] = "■"
            self.busy.append(i)
        self.ships.append(ship)  # Добавляем созданный корабль в список кораблей
        self.contour(ship)  # Вызываем метод contour, чтобы добавить окружающие корабль точки в список занятых

    def contour(self, ship, kill=False):  # Метод помечает занятыми точки рядом с кораблем. kill - состояние корабля
        # Это координаты смещения относительно точки корабля для определения координат соседних точек
        near = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        for i in ship.dots:  # i - точка корабля, для которой смотрим незанятых соседей
            for dx, dy in near:  # Координаты смещения помещаем в (дельта x) и (дельта y)
                current = Dot(i.x + dx, i.y + dy)  # Получаем новые соседние точки и проверяем их положение и состояние
                if not (self.out(current)) and current not in self.busy:
                    if kill:  # Если состояние корабля "убит", то незанятые соседние точки помечаем символом "◌"
                        self.field[current.x][current.y] = "◌"
                    self.busy.append(current)  # вносим полученную точку в список занятых

    # Этот метод выводит поля обоих игроков параллельно. Сперва идет поле объекта, от имени которого вызывался
    # метод, потом поле аргумента. В программе метод вызывается от объекта human, поэтому сперва выводится поле игрока,
    # но метод работает и для объекта ai, в таком случае первым будет идти поле ИИ
    def show_both(self, other):
        if other.hid:  # Пишем подписи в зависимости от того, кто где находится
            res = "Поле пользователя:" + " " * 16 + "Поле компьютера:\n"
        else:
            res = "Поле компьютера:" + " " * 18 + "Поле пользователя:\n"
        res += "—" * 29 + ' ' * 5 + "—" * 29
        res += "\n|x\\y| 1 | 2 | 3 | 4 | 5 | 6 |     |x\\y| 1 | 2 | 3 | 4 | 5 | 6 |\n"
        res += "—" * 29 + '     ' + "—" * 29
        for i, row in enumerate(zip(self.field, other.field)):
            res += f"\n| {i + 1} | " + " | ".join(row[0]) + f" |     | {i + 1} | " + " | ".join(row[1]) + " |\n"
            res += "—" * 29 + ' ' * 5 + "—" * 29
        res = res.replace("█", " ")  # Скрываем корабли компьютера.
        return res

    def out(self, dot):  # Проверка, что точка в пределах игрового поля
        return not ((0 <= dot.x < self.size) and (0 <= dot.y < self.size))

    def shot(self, dot):  # Метод для регистрации попаданий
        if self.out(dot):  # Если координата выстрела за границей поля, то вызываем ошибку
            raise BoardOutException()
        if dot in self.busy:  # Если координата выстрела приходится в уже проверенную точку, то вызываем ошибку
            raise BoardUsedException()
        self.busy.append(dot)  # Если всё хорошо, то добавляем точку в список проверенных(занятых)

        for ship in self.ships:
            if dot in ship.dots:  # Для всех кораблей проверяем есть ли попадание по ним
                ship.lives -= 1  # При попадании уменьшаем количество жизней корабля
                self.field[dot.x][dot.y] = "X"  # Помечаем подбитую точку корабля символом "X"
                if ship.lives == 0:
                    self.count -= 1  # Если у корабля нет жизней, то уменьшаем количество живых кораблей на 1
                    self.contour(ship, kill=True)  # Еще не занятые точки вокруг корабля помечаем знаком "◌"
                    print("Корабль уничтожен!")
                    return True  # При попадании получаем дополнительный ход
                else:
                    print("Корабль ранен!")
                    return True  # При попадании получаем дополнительный ход

        self.field[dot.x][dot.y] = "◌"  # Если выстрел пришелся на пустую точку, то помечаем ее "◌"
        print("Мимо!")
        return False  # При промахе ход переходит оппоненту

    # После размещения кораблей мы опустошаем список занятых точек, чтобы начать игру. В этот список будут заноситься
    # точки, куда были произведены выстрелы, и точки, которые находятся по соседству с затопленными кораблями
    def begin(self):
        self.busy = []


class Player:  # Родительский класс для User и AI
    def __init__(self, board, enemy):
        self.board = board  # Это собственная доска
        self.enemy = enemy  # Это доска оппонента

    def ask(self):  # Этот метод для потомков класса, тут оставляем его пустым
        raise NotImplementedError()

    def move(self):  # Метод, чтобы сделать выстрел
        while True:  # Пробуем сделать выстрел пока не получится
            try:
                target = self.ask()  # target - точка, куда делается выстрел
                repeat = self.enemy.shot(target)  # Если выстрел попал в цель, то repeat=True. Это +1 выстрел
                return repeat
            except BoardException as e:  # Отлавливаем тип ошибки
                print(e)


class AI(Player):  # Класс-потомок для ИИ
    def ask(self):  # ИИ делает выстрел в случайную точку. Уже занятые точки приниматься не будут
        while True:
            dot = Dot(randint(0, 5), randint(0, 5))  # ИИ делает выстрел в случайную точку в пределах поля боя
            if dot not in self.enemy.busy:  # Метод будет возвращать только еще не занятые точки
                print(f"Ход: {dot.x + 1} {dot.y + 1}")
                return dot


class User(Player):  # Класс-потомок для игрока
    def ask(self):  # У игрока спрашиваются координаты выстрела до тех пор, пока данные не будут корректны
        while True:
            coordinates = input("Ваш ход: ").replace(' ', '')  # Избавляемся от пробелов в координатах ввода
            if len(coordinates) == 2:  # Проверка результата на соответствие формату xy
                x, y = coordinates[0], coordinates[1]
            else:
                print("Неверный формат координат!")
                continue
            if not (x.isdigit()) or not (y.isdigit()):  # Проверка, что пользователь ввел числа
                print('Нужно ввести числовые значения координат!')
                continue
            return Dot(int(x) - 1, int(y) - 1)  # Вычитаем по 1, т.к. индексы в массиве идут с 0


class Game:  # Класс отвечает за процесс игры
    def __init__(self, size=6):
        self.size = size  # Размер игрового поля по условию задачи равен 6
        player = self.random_board()  # Создаем игровое поле с кораблями для пользователя
        computer = self.random_board(True)  # Создаем игровое поле с кораблями для компьютера. True - скрытие кораблей
        self.game_mode = Game.greeting()  # Выводим приветствие и определяем игровой режим
        if self.game_mode:
            self.human = User(player, computer)  # Пользователь сам вводит координаты
        else:
            self.human = AI(player, computer)  # Компьютер выбирает координаты вместо человека
        self.ai = AI(computer, player)  # ИИ стреляет по полю игрока, поэтому позиция аргументов зеркальная

    def random_board(self, ai=False):  # Метод пробует создать игровое поле с кораблями пока не получится
        board = None
        while board is None:
            board = self.random_place(ai)
        return board

    def random_place(self, ai):  # Метод за 2000 попыток пытается разместить корабли на поле боя
        fleet = [3, 2, 2, 1, 1, 1, 1]  # Список длин кораблей. Размещать начинаем с самых больших
        board = Board(size=self.size, hid=ai)  # Создаем пустое игровое поле заданного размера (6)
        attempts = 0  # Количество попыток разместить корабли
        for length in fleet:  # Последовательно пытаемся разместить корабли на поле боя
            while True:
                attempts += 1
                if attempts > 2000:  # Если не уложились в 2000 попыток, то скорее всего остальные корабли не влезут
                    return None      # даже если увеличить количество попыток. Поэтому возвращаем пустоту
                # Создаем корабль заданной длины со случайным положением точки носа и случайной ориентацией
                ship = Ship(Dot(randint(0, self.size), randint(0, self.size)), length, randint(0, 1))
                try:  # Пробуем разместить созданный корабль на поле боя
                    board.add_ship(ship)  # Если получилось разместить, то переходим к следующему кораблю в списке
                    break
                except BoardWrongShipException:  # Если возникла ошибка, то повторяем цикл while
                    pass
        board.begin()  # Опустошаем список занятых точек, т.к. началась игра, и все точки для оппонента не заняты
        return board

    @staticmethod
    def greeting():
        print("""----------------------------------------------------------------------------------
Игра "Морской бой"
----------------------------------------------------------------------------------
Правила игры:
Игроки по очереди стреляет по вражескому игровому полю, на котором расположены
следующие корабли: 1 трехпалубный, 2 двухпалубных и 4 однопалубных корабля.
Корабли не могут располагаться на соседних клетках, диагональ тоже учитывается.
Цель игры - уничтожить все вражеские корабли. При попадании по кораблю противника 
игрок получает дополнительный ход.
----------------------------------------------------------------------------------
Условные обозначения:
■ - корабль игрока
◌ - выстрел мимо (проверенная клетка)
X - попадание выстрелом в корабль
----------------------------------------------------------------------------------
Формат ввода координат:
xy или x y, где x - номер строки, y - номер столбца
----------------------------------------------------------------------------------
Режимы игры:
1) Человек против компьютера
2) Компьютер против компьютера
----------------------------------------------------------------------------------""")
        while True:  # Выбираем режим игры: return True - человек сам вводит координаты, return False - все делаем ИИ
            game_mode = input("Введите 1 или 2, чтобы выбрать режим игры: ")
            game_mode = game_mode.replace(' ', '')  # Убираем пробелы из пользовательского ввода
            if not game_mode.isdigit():  # Проверка, что получили число и можно использовать int
                print("Нужно ввести цифру!")
                continue
            game_mode = int(game_mode)
            if game_mode == 1:
                print('Вы выбрали режим "Человек против компьютера"!')
                return True
            elif game_mode == 2:
                print('Вы выбрали режим "Компьютер против компьютера"!')
                return False
            else:
                print("Нужно ввести 1 или 2!")

    def loop(self):
        turn = 0  # счетчик ходов, по нему определяем чей ход
        print()
        print(self.human.board.show_both(self.ai.board))  # Выводим поля обоих игроков
        while True:
            turn += 1
            if turn % 2 == 1:  # На нечетных значениях ходит человек, на четных - ИИ
                print()
                print("Ходит пользователь!")
                repeat = self.human.move()
            else:
                print()
                print("Ходит компьютер!")
                repeat = self.ai.move()
            if repeat:  # Если было попадание, то уменьшаем счетчик хода на 1, чтобы игрок сходил повторно
                turn -= 1
            print()
            print(self.human.board.show_both(self.ai.board))  # Выводим поля обоих игроков. Сперва будет поле человека
            if self.ai.board.count == 0:  # Если у ИИ кончились корабли, то победил человек
                print()
                print("Пользователь выиграл!")
                break
            if self.human.board.count == 0:  # Если у человека кончились корабли, то победил ИИ
                print()
                print("Компьютер выиграл!")
                break


match = Game()  # Создаем объект класса Game. Автоматически будет выведено приветствие и выбор режима игры
match.loop()  # Начинаем игру
